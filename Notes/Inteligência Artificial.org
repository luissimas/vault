#+title:Inteligência Artificial

A Inteligência Artificial é o ramo da ciência da computação relacionado com a automação do comportamento inteligente, operando através da criação de modelos para a inteligência e implementando sistemas computacionais baseados nesses modelos.

* Resolução de problemas por Busca
A resolução de problemas por busca consiste em modelar um problema usando uma representação do mundo baseada em *estados* e aplicar um *algoritmo de busca* sobre esses estados para encontrar uma solução para o problema.

** Representação de problemas
Para a resolução de problemas por busca é necessário definir o problema a ser resolvido. Essa definição é composta por dois grupos de elementos essenciais:
- *estados* que representam o mundo
- *ações* que provocam a alteração de um estado para outro

Nesse tipo de resolução assume-se que o ambiente no qual o problema se insere é:
- *observável*: o estado atual é conhecido.
- *discreto*: existe apenas um número finito de ações possíveis em cada estado.
- *conhecido*: o estado resultante de cada ação é conhecido.
- *determinístico*: cada ação leva a apenas um estado.

Para definir um problema são necessários 5 componentes:
- *Estado inicial:* estado a partir do qual a busca se inicia.
- *Ações (ou operadores):* possíveis ações aplicadas a cada estado.
- *Modelo de transição:* descrição do resultado de cada ação com base no estado atual e na ação tomada.
- *Teste final:* condições que determinam se um estado é o objetivo.
- *Custo do caminho:* função que atribui um custo ao caminho, mede a qualidade da solução.

Uma *solução* é uma sequência de ações que vai do estado inicial ao estado objetivo.

** Algoritmos de busca
Com um problema formulado, a solução consiste em realizar uma busca no espaço de estados até encontrar uma sequência de ações que atinjam o estado objetivo. O processo de busca acaba por construir uma *árvore de busca*, cuja raiz é o estado inicial, os nós são os demais estados, as ligações entre nós são as ações e a solução é o caminho da raiz até o nó final (estado objetivo).

No geral os algoritmos de busca possuem a mesma estrutura básica, que consiste em expandir os nós a partir das ações possíveis, gerando novos nós e repetir o processo até que se atinja o nó final. Apesar disso, os algoritmos diferem na *estratégia de busca*, que determina o critério usado para selecionar o próximo nó a ser expandido na árvore de busca.

*** Busca desinformada
As estratégias de busca desinformada não consideram informação adicional sobre o problema além da definição do mesmo. Tendo isso em vista, os algoritmos nessa categoria devem testar todos os nós até encontrar o estado objetivo.

[[../Attachments/IA/breadthanddepth.gif]]

**** Breadth-First (Busca em Largura)
Esse algoritmo consiste em verificar e expandir os nós da árvore de busca nível por nível, dessa forma todos os nós de um determinado nível são expandidos antes de se iniciar a expansão dos nós do próximo nível.

Uma implicação interessante da busca nível a nível é que esse algoritmo sempre encontra o *caminho mais curto* (não necessariamente o caminho ótimo) para a solução.

**** Depth-First (Busca em profundidade)
A busca em profundidade consiste em expandir o nó mais interno até que o nó desse ramo não tenha mais sucessores, após isso retrocede-se ao nó mais profundo e o processo é repetido.

Esse algoritmo *não garante* o caminho mais curto nem a solução ótima, mesmo se as ações tiverem o mesmo custo.

Note que em sua versão mais simples, a busca em profundidade apresenta algumas limitações. Uma delas é a possibilidade de expansão indefinida em um ramo, sem que a solução seja encontrada. Pensando nisso, algumas variações da busca em profundidade foram desenvolvidas na tentativa de remediar algumas dessas limitações fundamentais:

- Busca Limitada: define previamente um nível máximo para a expansão dos nós (note que caso o objetivo esteja em um nível abaixo do limite, ele não será encontrado).
- Busca Limitada Interativa: uma versão melhorada da busca limitada na qual o limite é dinâmico e vai sendo incrementado até que a solução seja atingida.
- Backtracking: apenas o caminho sendo explorado é armazenado, os filhos de cada nó são gerados e explorados um por vez.

**** Busca de Custo Uniforme
Esse algoritmo difere dos demais no sentido de que ele leva em conta o custo dos movimentos de um nó ao outro. A *função de custo* faz parte da definição do problema, e é utilizada por esse algoritmo para decidir qual nó expandir em seguida.

O algoritmo consiste em expandir o nó inicial, manter uma lista dos nós não expandidos ordenada pelo custo dos nós, e então visitar e expandir cada nó de acordo com a ordem dessa lista. Dessa forma os nós menos custosos são sempre verificados primeiro. Quando um nó é expandido, é necessário verificar se ele já havia sido visitado antes (mantendo um alista de nós já expandidos), caso ele já tenha sido visitado, é necessário comparar o custo do caminho atual com o do caminho anterior para aquele nó, e manter apenas o caminho menos custoso. Um ponto importante é que a verificação de nó objetivo só deve ser feita no nó selecionado, e não nos nós expandidos, pois com o primeiro método há a garantia de encontrar sempre o caminho menos custoso para o nó objetivo.

Note que o algoritmo de busca de custo uniforme garante sempre a *solução ótima*, ou seja, a solução de menor custo para o problema.

*** Busca informada
Ao contrário da busca desinformada, a busca informada é uma estratégia de busca que considera *informação específica sobre o problema*, que vão além da definição básica do problema. Nesse tipo de busca, as informações sobre o problema são usadas no momento de selecionar o *próximo nó* a ser expandido. Dessa forma, essa estratégia *não é exaustiva*, ou seja, há mecanismos para evitar que todos os nós devem ser testados para se encontrar o estado objetivo.

As informações específicas ao problema são formuladas como *heurísticas*, que são regras simples utilizadas para avaliar rapidamente um estado. As heurísticas são expressas como funções, de forma que é possível aplicá-las a cada estado.

As heurísticas permitem a aproximação de uma solução, por essa razão são utilizadas principalmente em situações nas quais um problema não possui uma solução exata, ou se essa solução existe mas é muito custosa computacionalmente.

Vale destacar que as buscas com base em heurísticas são *sujeitas a falhas*, no sentido de que a busca pode não encontrar a solução ou encontrar uma solução sub-ótima.

**** Busca pela melhor escolha (best-first)
A busca pela melhor escolha utiliza as heurísticas na forma de uma *função de avaliação* $f(n)$, que aplicada a um estado retorna um valor numérico. A função de avaliação é utilizada para determinar o *quão desejável* é expandir um determinado nó.

De maneira semelhante aos algoritmos de busca desinformada, esse tipo algoritmo mantém listas de nós abertos e fechados, mas armazena também para cada nó expandido o valor da função de avaliação aplicada a ele. Dessa forma, o algoritmo *expande primeiro* os nós com o *melhor valor* da função de avaliação.

A *função de avaliação* pode levar em conta duas métricas:

- A *função de custo* $g(n)$, que representa o custo do caminho da raiz até o nó $n$.
- A *função heurística* $h(n)$, que representa a estimativa de custo do caminho do nó $n$ até o objetivo.

  Vale destacar que o algoritmo de busca pela melhor escolha é na realidade um *modelo* que *engloba diversos outros algoritmos* de busca informada. A ideia geral do algoritmo se mantém, mas as variações de algoritmos surgem nas *diferentes definições* para a *função de avaliação*.

***** Busca Gulosa (Greedy)
Esse algoritmo utiliza como função de avaliação apenas a *função heurística*, ou seja, $f(n) = h(n)$. Dessa forma, os nós considerados mais próximos do objetivo são expandidos primeiro.

Note que não há nenhuma garantia de que esse algoritmo encontra a solução ótima. Entretanto, esse algoritmo é *geralmente* muito *rápido* (pois a função heurística geralmente é de baixo custo computacional). Isso torna o algoritmo de busca gulosa desejável em situações onde o desempenho é preferível ao invés da solução ótima.

***** A*
Utiliza como função de avaliação uma soma da *função de custo* e da *função heurística*, portanto $f(n) = g(n) + h(n)$. Sendo assim, esse algoritmo considera não só a estimativa do custo do caminho do nó $n$ até o objetivo, mas também o custo do caminho percorrido até o nó.

A garantia de que esse algoritmo encontra a *solução ótima* depende da definição da *função heurística*. Se a função heurística nunca superestima o custo de alcançar um objetivo, ou seja, $h(n)$ nunca ultrapassa o custo real do caminho de $n$ até o objetivo, então o algoritmo A* encontra sempre a solução ótima.

**** Busca Local
Os algoritmos de busca local diferem bastante dos outros enunciados até o momento. Essa classe de algoritmos levam em conta *apenas o estado corrente* e se movem apenas para os estados vizinhos deste, *sem levar em conta os caminhos para os estados*. Dessa forma, esse tipo de algoritmo *não mantém* uma lista de *nós abertos e fechados*, sendo necessário armazenar *apenas o estado atual* para então expandi-lo e avaliar os estados possíveis a partir deste.

Esses algoritmos geralmente são *eficientes em termos de memória*, pois não é necessário manter todo o espaço de estados armazenado através de listas de nós. Entretanto, podem muitas vezes levar a *soluções sub-ótimas* ou não levar a solução alguma.

Geralmente os algoritmos de busca local atuam bem em problemas de otimização, nos quais o objetivo é encontrar o *melhor estado* de acordo com uma *função objetivo*.

***** Hill-climbing
O algoritmo hill-climbing é um exemplo claro de algoritmo de busca local. Ele consiste em *expandir um nó* e *avaliar seus descendentes* através de alguma função, que geralmente envolve alguma heurística do problema. Em seguida, o nó com a *melhor avaliação* entre os descendentes é *selecionado* para continuar a busca, e o processo se repete até que o nó selecionado *não gere descendentes com uma avaliação melhor*.

* Representação de Conhecimento e Raciocínio

* Aprendizado de Máquina
